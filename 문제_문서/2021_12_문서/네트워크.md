#   정답
```java
class Solution {
    public int solution(int n, int[][] computers) {
        /*
        
        노드들, 네트워크 수, 방문
        
        노드들 == n
        
        방문한 노드들
        
        기존 문제들은 dfs를 root부터 시작하는 것이였는데 이거는 root가 여러개인 것임 그래서
        
        for문을 돌면서 각 root에서 dfs를 해줘야 하는것임
        
        그리고 각 root들을 방문했는지 체크하는 visted[]가 필요한 것임
        
        visited에 이미 1로 되어있는것은 다른 root에서 해당 노드를 방문한 것이기 때문에 같은 네트워크에 속한다.
        
        그래서 visited에 없는 dfs를 해야 네트워크수를 카운트 할 수 있는 것이다.
        
        */
        int[] visited = new int[n];
        
        int answer = 0;
        
        for(int root = 0; root < computers.length; root++){
            if(visited[root] != 1){
                dfs(computers, root, visited);
                answer++;
            }
        }
        
        
        return answer;
    }
    
    private void dfs(int[][] computers, int nodeNum, int[] visited){
        visited[nodeNum] = 1;

        if(nodeNum == computers.length){
            return;
        }else{
            for(int nextNum = 0; nextNum < computers.length; nextNum++){
                if(nodeNum != nextNum 
                   && computers[nodeNum][nextNum] == 1
                   && visited[nextNum] != 1){
                    dfs(computers, nextNum, visited);
                }

            }
        }
    }
}
```
행렬은 노드의 연결 관계를 나타낸다.

